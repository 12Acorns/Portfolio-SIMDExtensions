using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System;
using SIMDExtensions_Generator.Generators.Types;
using SIMDExtensions_Generator.Generators.Data;
using SIMDExtensions_Generator.Extensions;
using SIMDExtensions_Generator.Generators.Types.Meta;

namespace SIMDExtensions_Generator;

//[global::System.Runtime.CompilerServices.CompilerGenerated]

[Generator]
internal partial class VectorGenerator : IIncrementalGenerator
{
	static VectorGenerator()
	{
//#if DEBUG
//		if(!Debugger.IsAttached)
//		{
//			Debugger.Launch();
//		}
//#endif
	}

	private static readonly Dictionary<VectorFunction, SupportMemberInfo[]> avx512SupportedMembers = new()
	{
		{
			VectorFunction.Add,
			[
				new("Vector512", [], new(["double", "float", "int", "long", "uint", "ulong"])),
				new("Vector256", [], defaultInputTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Subtract,
			[
				new("Vector512", [], new(["double", "float", "int", "long", "uint", "ulong"])),
				new("Vector256", [], defaultInputTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Multiply,
			[
				new("Vector512", multiplyReturnInfo, singleAndIntSupportedTypes),
				new("Vector256", multiplyReturnInfo, singleAndIntSupportedTypes),
				new("Vector128", multiplyReturnInfo, singleAndIntSupportedTypes)
			]
		},
		{
			VectorFunction.Divide,
			[
				new("Vector512", [], singleSupportedTypes),
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", [], singleSupportedTypes)
			]
		},
	};
	private static readonly Dictionary<VectorFunction, SupportMemberInfo[]> avx256SupportedMembers = new()
	{
		{
			VectorFunction.Add,
			[
				new("Vector256", [], defaultInputTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Subtract,
			[
				new("Vector256", [], defaultInputTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Multiply,
			[
				new("Vector256", multiplyReturnInfo, singleAndIntSupportedTypes),
				new("Vector128", multiplyReturnInfo, singleAndIntSupportedTypes),
			]
		},
		{
			VectorFunction.Divide,
			[
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", [], singleSupportedTypes)
			]
		},
	};
	private static readonly Dictionary<VectorFunction, SupportMemberInfo[]> avx128SupportedMembers = new()
	{
		{
			VectorFunction.Add,
			[
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Subtract,
			[
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", [], defaultInputTypes)
			]
		},
		{
			VectorFunction.Multiply,
			[
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", multiplyReturnInfo, new(["double", "float", "int", "uint"]))
			]
		},
		{
			VectorFunction.Divide,
			[
				new("Vector256", [], singleSupportedTypes),
				new("Vector128", [], singleSupportedTypes)
			]
		}
	};
	private static readonly Dictionary<VectorFunction, SupportMemberInfo[]> genericSupportedMembers = new()
	{
		{
			VectorFunction.Add,
			[
			]
		},
		{
			VectorFunction.Subtract,
			[
			]
		},
		{
			VectorFunction.Multiply,
			[
			]
		},
		{
			VectorFunction.Divide,
			[
			]
		}
	};

	private static readonly SupportType singleAndIntSupportedTypes = new(["double", "float", "int", "uint"]);
	private static readonly SupportType singleSupportedTypes = new(["double", "float"]);
	private static readonly SupportType defaultInputTypes = new([
		"double", "float", "short", "int", "long",
		"ushort", "uint", "ulong", "sbyte", "byte"]);
	private static readonly ReturnInfo[] multiplyReturnInfo =
	[
		new("int", "long"),
		new("uint", "ulong")
	];
	private readonly List<(string _name, string[] _members)> enumTypes = [];
	private const string GLOBALVECTORNUMERICNAMESPACE = "global::System.Numerics";
	private const string GLOBALINTRINSICSNAMESPACE = "global::System.Runtime.Intrinsics";
	private const string GLOBALVECTORNAMESPACE = "global::SIMDExtensions_Core.Vectors";
	private const string GLOBALX86NAMESPACE = "global::System.Runtime.Intrinsics.X86";

	#region Templates
	private const string PARTIALMETHODTEMPLATE = """
			static partial void {2}({0}.BaseVector<T> _lhs, 
				{0}.BaseVector<T> _rhs, ref {0}.BaseVector<T> _ret)
			{{
				{1}
			}}
		""";
	private const string BASECLASS = """
		// <autogenerated/>
		using global::System.Runtime.Intrinsics.X86;
		using global::System.Runtime.InteropServices;
		using global::System.Runtime.Intrinsics.Arm;
		using global::System.Runtime.Intrinsics;
		using global::System.Numerics;

		namespace SIMDExtensions_Core.Vectors;

		[global::System.CodeDom.Compiler.GeneratedCode("VectorGenerator", "1.0.0")]
		public readonly ref partial struct BaseVector<T> where T : INumber<T>
		{

		""";

	#endregion

	public void Initialize(IncrementalGeneratorInitializationContext _context)
	{
		var _provider = _context.SyntaxProvider.CreateSyntaxProvider(
			static (_node, _) => _node is ObjectCreationExpressionSyntax _creation,
			static (_ctx, _) => AnalyzeCreation(_ctx))
			.Where(_creation => _creation is not null);

		var _enumProvider = _context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (_node, _) => _node is EnumDeclarationSyntax,
				transform: (_context, _) => GetEnumInfo((EnumDeclarationSyntax)_context.Node))
			.Where(static _enumInfo => _enumInfo != null);

		var _compilation = _context.CompilationProvider
			.Combine(_provider.Collect());

		var _enumCompilation = _context.CompilationProvider
			.Combine(_enumProvider.Collect());

		_context.RegisterSourceOutput(_enumCompilation, DummyEx);
		_context.RegisterSourceOutput(_compilation, Execute);
	}

	private static void DummyEx(SourceProductionContext _context, 
		(Compilation _left, ImmutableArray<(string _enumName, string[] _memberNames)?> _right) _tuple) { }
	private void Execute(SourceProductionContext _prodContext,
		(Compilation _left, ImmutableArray<ObjectCreationExpressionSyntax> _right) _tup)
	{
		var (_compilation, _vectorDeclarations) = _tup;

		if(_vectorDeclarations == null)
			return;

		var _meta = new MetaGenerator();

		var (_models, _symbolMeta) = GetStructSymbol(_compilation, _vectorDeclarations.AsSpan());
		var _distinctModels = _models.GroupBy(x => x.Symbol.TypeArguments[0].Name).Select(x => x.First());
		var (_code, _callerMeta) = BuildCode(_distinctModels);

		_meta.WithCallerMeta(_callerMeta);
		_meta.WithSymbolMeta(_symbolMeta);

		var _writeCode = _meta.Generate() + BASECLASS + _code + '}';

		_prodContext.AddSource("gen_BaseVector.g.cs", _writeCode);
	}
	private (string _code, MetaGenerator.MetaCallerGenerator _callerMeta) BuildCode(IEnumerable<ModelData> _models)
	{
		var _ctorData = _models
			.Select(x => 
				new CtorData(
					x.Symbol.TypeArguments[0].ToDisplayString(),
					x.Model, 
					x.VectorCreation));

		var _codeBuilder = new StringBuilder(new CtorGenerator(_ctorData).Generate())
			.Append("\n    internal readonly Type vectorType;");

		foreach(var _enumMember in Enum.GetValues(typeof(VectorFunction)).Cast<VectorFunction>())
		{
			var _funcName = _enumMember.ToFuncName();

			_codeBuilder.AppendLine()
				.AppendFormat(PARTIALMETHODTEMPLATE, 
				GLOBALVECTORNAMESPACE, BuildOperator(_funcName), 
				_funcName);
		}
		_codeBuilder
			.AppendLine()
				.AppendLine(BuildOperatorMethods(_models, VectorFunction.Add))
				.AppendLine(BuildOperatorMethods(_models, VectorFunction.Subtract))
				.AppendLine(BuildOperatorMethods(_models, VectorFunction.Multiply))
				.AppendLine(BuildOperatorMethods(_models, VectorFunction.Divide));

		return (_codeBuilder.ToString(), new MetaGenerator.MetaCallerGenerator(_ctorData));
	}
	private string BuildOperatorMethods(ModelData _data, VectorFunction _function)
	{
		var _methodBuilder = new StringBuilder();
		foreach(var (_name, _members) in enumTypes)
		{
			if(_name is not "ArchitectureType")
			{
				continue;
			}
			_methodBuilder.AppendLine();

			foreach(var _appender in BuildOperatorFromEnum(_function, _data, _members))
			{
				_methodBuilder.Append(_appender);
			}
		}

		return _methodBuilder.ToString();
	}
	private IEnumerable<string> BuildOperatorFromEnum(VectorFunction _vectorFunc, ModelData _data, string[] _enums)
	{
		foreach(var _enumMember in _enums)
		{
			if(_enumMember is "None")
			{
				continue;
			}

			var _supportedTypeInfo = SupportedTypes(_enumMember)[_vectorFunc];

			var _buildOperatorBuilder = new StringBuilder();
			foreach(var _supportInfo in _supportedTypeInfo)
			{
				_buildOperatorBuilder.AppendLine()
					.Append(BuildOperatorExecution(_supportInfo, _vectorFunc, _data, _enumMember));
			}

			yield return string.Format("""
				private static bool {0}{1}({2}.BaseVector<T> _lhs, {2}.BaseVector<T> _rhs, ref {2}.BaseVector<T> _ret)
				{{
					{3}
					return true;
				}}
				""", _enumMember, _vectorFunc, GLOBALVECTORNAMESPACE, _buildOperatorBuilder.ToString());
		}
	}
	private string BuildOperatorExecution(SupportMemberInfo _info, VectorFunction _vectorFunc,
		ModelData _data, string _enumMember)
	{
		var _funcName = _vectorFunc.ToFuncName();
		var _inputGenericType = _data.Symbol.TypeArguments[0].ToDisplayString();

		string _outputCastType = $".As<T, {_inputGenericType}>()";
		foreach(var _typeTReturn in _info.ReturnTypeIfTIs)
		{
			if(_typeTReturn.Input != _inputGenericType)
			{
				continue;
			}
			_outputCastType = $".As<T, {_typeTReturn.ReturnType}>()";
			break;
		}

		var _vectorType = _info.VectorType;
		var _inputCastType = $".As<T, {_inputGenericType}>()";
		if(_vectorFunc is VectorFunction.Divide)
		{
			if(_inputGenericType is not "float" or "double")
			{
				_inputCastType = ".AsSingle()";
			}
		}
		else if(!_info.SupportedTypes.IsSupported(_inputGenericType))
		{

		}

		// {0) => GLOBALVECTORNAMESPACE
		// {1} => GLOBALINTRINSICSNAMESPACE
		// {2} => GLOBALX86NAMESPACE
		// {3} => Function Name
		// {4} => Function Cast Return Type
		// {5} => Input Cast Type
		var _functionTemplate = _enumMember switch
		{
			"AVX512" => """
				_ret = new {0}.BaseVector<T>({2}.Avx512F.{3}(_lhs.vector512.Value{5}, 
					_rhs.vector512.Value{5}){4});
				""",

			"AVX2" => """
				_ret = new {0}.BaseVector<T>({2}.Avx2.{3}(_lhs.vector256.Value{5}, 
					_rhs.vector256.Value{5}){4});
				""",

			"AVX" => """
				_ret = new {0}.BaseVector<T>({2}.Avx.{3}(_lhs.vector256.Value{5}, 
					_rhs.vector256.Value{5}){4});
				""",
			_ => string.Empty
		};

		return string.Format(_functionTemplate, GLOBALVECTORNAMESPACE,
			GLOBALINTRINSICSNAMESPACE, GLOBALX86NAMESPACE, _funcName,
			_outputCastType, _inputCastType);
	}

	private string BuildOperator(string _operatorName)
	{
		const string _TEMPLATE = """
			_ = targetPlatform switch
					{{
			{0}
					}};
			""";

		var _operatorBuilder = new StringBuilder();
		foreach(var (_name, _members) in enumTypes)
		{
			if(_name is not "ArchitectureType")
			{
				continue;
			}
			
			foreach(var _enumMember in _members)
			{
				if(_enumMember is "None")
				{
					_operatorBuilder.AppendFormat("""
								{0}.None => throw new PlatformNotSupportedException("SIMD not supported"),
					""", _name);
					continue;
				}
				_operatorBuilder.AppendLine()
					.AppendFormat("""
								{0}.{1} => {1}{2}(_lhs, _rhs, ref _ret),
					""", _name, _enumMember, _operatorName);
			}
		}
		var _ret = string.Format(_TEMPLATE, _operatorBuilder.ToString());

		return _ret;
	}
	private Dictionary<VectorFunction, SupportMemberInfo[]> SupportedTypes(string _enumMember)
	{
		return _enumMember switch
		{
			"AVX512" => avx512SupportedMembers,
			"AVX2" => avx256SupportedMembers,
			"AVX" => avx128SupportedMembers,
			_ => genericSupportedMembers,
		};
	}
	private (IEnumerable<ModelData> _data, MetaGenerator.MetaSymbolGenerator _symbolMeta) GetStructSymbol(
		Compilation _compilation, ReadOnlySpan<ObjectCreationExpressionSyntax> _vectorCreations)
	{
		var _models = new List<ModelData>(_vectorCreations.Length);
		foreach(var (_vectorCreation, _index) in _vectorCreations.Indexed())
		{
			var _semanticModel = _compilation.GetSemanticModel(_vectorCreation.SyntaxTree);
			var _typeInfo = _semanticModel.GetTypeInfo(_vectorCreation);

			if(_typeInfo.Type is not INamedTypeSymbol _structSymbol)
			{
				return (null, $"// Type: '{_typeInfo.Type}' was not type: '{typeof(INamedTypeSymbol)}'");
			}
			if(_structSymbol.TypeArguments.Length != 1)
			{
				return (null,
					$"// Arguments of {_structSymbol.TypeArguments} did not match expected length\n" +
					$"// Got: {_structSymbol.TypeArguments.Length}\n// Expected: 1");
			}
			_models.Add(new ModelData(_structSymbol, _semanticModel, _vectorCreation));
		}

		return (_models, new MetaGenerator.MetaSymbolGenerator());
	}
	private (string _enumName, string[] _memberNames)? GetEnumInfo(EnumDeclarationSyntax _enumDeclaration)
	{
		var _enumName = _enumDeclaration.Identifier.Text;

		if(_enumName is not "ArchitectureType")
		{
			return null;
		}

		var _memberNames = _enumDeclaration.Members.Select(m => m.Identifier.Text).ToArray();

		enumTypes.Add((_enumName, _memberNames));
		return (_enumName, _memberNames);
	}
	private static ObjectCreationExpressionSyntax? AnalyzeCreation(GeneratorSyntaxContext _context)
	{
		// Ensure the node is an ObjectCreationExpressionSyntax
		if(_context.Node is not ObjectCreationExpressionSyntax _creation)
			return null;

		var semanticModel = _context.SemanticModel;
		var typeInfo = semanticModel.GetTypeInfo(_creation);

		// Check if the type being instantiated is a generic struct named "BaseVector"
		if(typeInfo.Type is not INamedTypeSymbol _structSymbol || _structSymbol.TypeKind != TypeKind.Struct)
		{
			return null;
		}
		return _structSymbol.Name switch
		{
			"BaseVector" when _structSymbol.IsGenericType => _creation,
			_ => null
		};
	}
}